[{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jackson G Lu. Author. Elizabeth Page-Gould. Author. Nancy R Xu. Author, maintainer.","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lu JG, Page-Gould E, Xu NR (2017). MicroMacroMultilevel: Micro-Macro Multilevel Modeling. R package version 0.4.0, https://CRAN.R-project.org/package=MicroMacroMultilevel.","code":"@Manual{,   title = {MicroMacroMultilevel: Micro-Macro Multilevel Modeling},   author = {Jackson G Lu and Elizabeth Page-Gould and Nancy R Xu},   year = {2017},   note = {R package version 0.4.0},   url = {https://CRAN.R-project.org/package=MicroMacroMultilevel}, }"},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/index.html","id":"micromacromultilevel--micro-macro-multilevel-modeling","dir":"","previous_headings":"","what":"Micro-Macro Multilevel Modeling","title":"Micro-Macro Multilevel Modeling","text":"multilevel methodologies can model macro-micro multilevel situations unbiased way, wherein group-level predictors (e.g., city temperature) used predict individual-level outcome variable (e.g., citizen personality). contrast, R package enables researchers model micro-macro situations, wherein individual-level (micro) predictors (group-level predictors) used predict group-level (macro) outcome variable unbiased way.","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Micro-Macro Multilevel Modeling","text":"Refer package index reference manual documentation.","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Micro-Macro Multilevel Modeling","text":"Install CRAN using:","code":"install.packages(\"MicroMacroMultilevel\")"},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Micro-Macro Multilevel Modeling","text":"Please cite package use :","code":"citation(\"MicroMacroMultilevel\") #> To cite package 'MicroMacroMultilevel' in publications use: #>  #>   Lu JG, Page-Gould E, Xu NR (2017). _MicroMacroMultilevel: Micro-Macro #>   Multilevel Modeling_. R package version 0.4.0, #>   <https://CRAN.R-project.org/package=MicroMacroMultilevel>. #>  #> A BibTeX entry for LaTeX users is #>  #>   @Manual{, #>     title = {MicroMacroMultilevel: Micro-Macro Multilevel Modeling}, #>     author = {Jackson G Lu and Elizabeth Page-Gould and Nancy R Xu}, #>     year = {2017}, #>     note = {R package version 0.4.0}, #>     url = {https://CRAN.R-project.org/package=MicroMacroMultilevel}, #>   }"},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/adjusted.predictors.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculating the Adjusted Group Means of Individual-Level Variables in a Micro-Macro Multilevel Situation — adjusted.predictors","title":"Calculating the Adjusted Group Means of Individual-Level Variables in a Micro-Macro Multilevel Situation — adjusted.predictors","text":"prerequisite step fitting micro-macro multilevel model, function calculates adjusted group means individual-level predictors unbiased way.","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/adjusted.predictors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculating the Adjusted Group Means of Individual-Level Variables in a Micro-Macro Multilevel Situation — adjusted.predictors","text":"","code":"adjusted.predictors(x.data, z.data, x.gid, z.gid)"},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/adjusted.predictors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculating the Adjusted Group Means of Individual-Level Variables in a Micro-Macro Multilevel Situation — adjusted.predictors","text":"x.data N--p data frame individual-level predictors, N denotes total number individuals p denotes number individual-level predictors. Must contain NAs. z.data G--q data frame group-level predictors, G denotes total number groups q denotes number group-level predictors. Must contain NAs. x.gid array N--1 numeric matrix individual's group ID. order corresponds individuals x.data. Duplicates expected. z.gid array G--1 numeric matrix Group ID. order corresponds groups z.data. group IDs unique (.e., duplicates allowed).","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/adjusted.predictors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculating the Adjusted Group Means of Individual-Level Variables in a Micro-Macro Multilevel Situation — adjusted.predictors","text":"adjusted.group.means G--(p+q+1) numeric matrix contains p adjusted group means individual-level variables x.data, q group-level predictors z.data, unique group IDs. unequal.groups boolean variable. TRUE = group size different across groups; FALSE = group size across groups. group.size G--2 data frame displays unique group IDs corresponding group sizes.","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/adjusted.predictors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculating the Adjusted Group Means of Individual-Level Variables in a Micro-Macro Multilevel Situation — adjusted.predictors","text":"date, multilevel methodologies can unbiasedly model macro-micro multilevel situations, wherein group-level predictors (e.g., city temperature) used predict individual-level outcome variable (e.g., citizen personality). contrast, R package enables researchers model micro-macro situations, wherein individual-level (micro) predictors (group-level predictors) used predict group-level (macro) outcome variable unbiased way. conduct micro-macro multilevel modeling current package, one must first compute adjusted group means function adjusted.predictors. micro-macro multilevel modeling, statistically biased directly regress group-level outcome variable unadjusted group means individual-level predictors (Croon & van Veldhoven, 2007). Instead, one use best linear unbiased predictors (BLUP) group means (.e., adjusted group means), conveniently computed adjusted.predictors. produced adjusted.predictors, adjusted group means can used one inputs micromacro.lm function, reports estimation results inferential statistics micro-macro multilevel model interest. Importantly, adjusted.predictors also reports whether group size across groups, critical dummy input micromacro.lm function.","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/adjusted.predictors.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculating the Adjusted Group Means of Individual-Level Variables in a Micro-Macro Multilevel Situation — adjusted.predictors","text":"Akinola, M., Page-Gould, E., Mehta, P. H., & Lu, J. G. (2016). Collective hormonal profiles predict group performance. Proceedings National Academy Sciences, 113 (35), 9774-9779. Croon, M. ., & van Veldhoven, M. J. (2007). Predicting group-level outcome variables variables measured individual level: latent variable multilevel model. Psychological Methods, 12(1), 45-57.","code":""},{"path":[]},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/adjusted.predictors.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculating the Adjusted Group Means of Individual-Level Variables in a Micro-Macro Multilevel Situation — adjusted.predictors","text":"Jackson G. Lu, Elizabeth Page-Gould, Nancy R. Xu (maintainer, nancyranxu@gmail.com).","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/adjusted.predictors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculating the Adjusted Group Means of Individual-Level Variables in a Micro-Macro Multilevel Situation — adjusted.predictors","text":"","code":"######## SETUP: DATA GENERATING PROCESSES ######## set.seed(123) # Step 1. Generate a G-by-q data frame of group-level predictors (e.g., control variables), z.data # In this example, G = 40, q = 2 group.id = seq(1, 40) z.var1 = rnorm(40, mean=0, sd=1) z.var2 = rnorm(40, mean=100, sd=2) z.data = data.frame(group.id, z.var1, z.var2) # Step 2. Generate a G-by-p data frame of group-level means for the predictors that will be used to # generate x.data # In this example, there are 3 individual-level predictors, thus p = 3 x.var1.means = rnorm(40, mean=50, sd = .05) x.var2.means = rnorm(40, mean=20, sd = .05) x.var3.means = rnorm(40, mean=-10, sd = .05) x.data.means = data.frame(group.id, x.var1.means, x.var2.means, x.var3.means) # Step 3. Generate two N-by-p data frames of individual-level predictors, x.data # One of these two data frames assumes unequal-sized groups (Step 3a), # whereas the other assumes equal-sized groups (Step 3b): # Step 3a. Generate the individual-level predictors # In this example, N = 200 and group size is unequal x.data.unequal = data.frame( group.id=rep(1:40, times=sample( c(4,5,6), 40, replace=TRUE) )[1:200] ) x.data.unequal = merge( x.data.unequal,               data.frame( group.id, x.var1.means, x.var2.means, x.var3.means ), by=\"group.id\" ) x.data.unequal = within( x.data.unequal, {   x.var1 = x.var1.means + rnorm(200, mean=0, sd = 2)   x.var2 = x.var2.means + rnorm(200, mean=0, sd = 6)   x.var3 = x.var3.means + rnorm(200, mean=0, sd = 1.5) }) # Step 3b. Generate the individual-level predictors # In this example, N = 200 and group size is equal x.data.equal = data.frame( group.id=rep(1:40, each=5) ) x.data.equal = merge( x.data.equal, x.data.means, by=\"group.id\" ) x.data.equal = within( x.data.equal, {   x.var1 = x.var1.means + rnorm(200, mean=0, sd = 2)   x.var2 = x.var2.means + rnorm(200, mean=0, sd = 6)   x.var3 = x.var3.means + rnorm(200, mean=0, sd = 1.5) }) # Step 3. Generate a G-by-1 data frame of group-level outcome variable, y # In this example, G = 40 y = rnorm(40, mean=6, sd=5)  apply(x.data.equal,2,mean) #>     group.id x.var1.means x.var2.means x.var3.means       x.var3       x.var2  #>    20.500000    50.000393    19.994708    -9.999167    -9.955875    19.871931  #>       x.var1  #>    50.138110  #    group.id x.var1.means x.var2.means x.var3.means       x.var3       x.var2       x.var1 # 20.500000    50.000393    19.994708    -9.999167   -10.031995    20.185361    50.084635 apply(x.data.unequal,2,mean) #>     group.id x.var1.means x.var2.means x.var3.means       x.var3       x.var2  #>     20.38000     50.00119     19.99384    -10.00026     -9.99205     20.07592  #>       x.var1  #>     50.04153  #    group.id x.var1.means x.var2.means x.var3.means       x.var3       x.var2       x.var1 # 20.460000    50.002286    19.994605    -9.997034    -9.983146    19.986111    50.123591 apply(z.data,2,mean) #>    group.id      z.var1      z.var2  #> 20.50000000  0.04518332 99.98656817  # z.var1      z.var2 # 0.04518332 99.98656817 mean(y) #> [1] 6.355156 # 6.457797  ######## EXAMPLE 1. GROUP SIZE IS DIFFERENT ACROSS GROUPS ######## ######## Need to use adjusted.predictors() in the same package ###  # Step 4a. Generate a G-by-1 matrix of group ID, z.gid. Then generate an N-by-1 matrix of # each individual's group ID, x.gid, where the group sizes are different z.gid = seq(1:40) x.gid = x.data.unequal$group.id # Step 5a. Generate the best linear unbiased predictors that are calcualted from # individual-level data x.data = x.data.unequal[,c(\"x.var1\",\"x.var2\",\"x.var3\")] results = adjusted.predictors(x.data, z.data, x.gid, z.gid) # Note: Given the fixed random seed, the output should be as below results$unequal.groups #> [1] TRUE # TRUE names(results$adjusted.group.means) #> [1] \"BLUP.x.var1\" \"BLUP.x.var2\" \"BLUP.x.var3\" \"group.id\"    \"z.var1\"      #> [6] \"z.var2\"      \"gid\"         # \"BLUP.x.var1\" \"BLUP.x.var2\" \"BLUP.x.var3\" \"z.var1\"      \"z.var2\"      \"gid\" head(results$adjusted.group.means) #>   BLUP.x.var1 BLUP.x.var2 BLUP.x.var3 group.id      z.var1    z.var2 gid #> 1    50.26217    22.87471  -10.269459        1 -0.56047565  98.61059   1 #> 2    50.07401    19.27554  -10.212717        2 -0.23017749  99.58417   2 #> 3    49.41058    18.73552  -10.503523        3  1.55870831  97.46921   3 #> 4    50.16042    21.18500   -9.739461        4  0.07050839 104.33791   4 #> 5    50.08519    20.34232   -9.922236        5  0.12928774 102.41592   5 #> 6    50.02981    21.47008  -10.419274        6  1.71506499  97.75378   6 #   BLUP.x.var1 BLUP.x.var2 BLUP.x.var3 group.id      z.var1    z.var2 gid # 1    50.05308    20.83911  -10.700361        1 -0.56047565  98.61059   1 # 2    48.85559    22.97411   -9.957270        2 -0.23017749  99.58417   2 # 3    50.16357    19.50001   -9.645735        3  1.55870831  97.46921   3 # 4    49.61853    21.25962  -10.459398        4  0.07050839 104.33791   4 # 5    50.49673    21.38353   -9.789924        5  0.12928774 102.41592   5 # 6    50.86154    19.15901   -9.245675        6  1.71506499  97.75378   6  ######## EXAMPLE 2. GROUP SIZE IS THE SAME ACROSS ALL GROUPS ######## ######## Need to use adjusted.predictors() in the same package ###  # Step 4b. Generate a G-by-1 matrix of group ID, z.gid. Then generate an N-by-1 matrix of # each individual's group ID, x.gid, where group size is the same across all groups z.gid = seq(1:40) x.gid = x.data.equal$group.id # Step 5b. Generate the best linear unbiased predictors that are calcualted from # individual-level data x.data = x.data.equal[,c(\"x.var1\",\"x.var2\",\"x.var3\")] results = adjusted.predictors(x.data, z.data, x.gid, z.gid) results$unequal.groups #> [1] FALSE # FALSE names(results$adjusted.group.means) #> [1] \"BLUP.x.var1\" \"BLUP.x.var2\" \"BLUP.x.var3\" \"group.id\"    \"z.var1\"      #> [6] \"z.var2\"      \"gid\"         # \"BLUP.x.var1\" \"BLUP.x.var2\" \"BLUP.x.var3\" \"z.var1\"      \"z.var2\"      \"gid\" results$adjusted.group.means[1:5, ] #>   BLUP.x.var1 BLUP.x.var2 BLUP.x.var3 group.id      z.var1    z.var2 gid #> 1    49.76696    21.68605  -10.035639        1 -0.56047565  98.61059   1 #> 2    49.90570    19.91467   -9.625758        2 -0.23017749  99.58417   2 #> 3    50.03031    20.76583  -11.141062        3  1.55870831  97.46921   3 #> 4    50.27814    21.22401   -9.068284        4  0.07050839 104.33791   4 #> 5    50.11567    19.13808   -9.882101        5  0.12928774 102.41592   5 #   BLUP.x.var1 BLUP.x.var2 BLUP.x.var3 group.id      z.var1    z.var2 gid # 1    50.91373    19.12994  -10.051647        1 -0.56047565  98.61059   1 # 2    50.19068    19.17978  -10.814382        2 -0.23017749  99.58417   2 # 3    50.13390    20.98893   -9.952348        3  1.55870831  97.46921   3 # 4    49.68169    19.60632  -10.612717        4  0.07050839 104.33791   4 # 5    50.28579    22.07469  -10.245505        5  0.12928774 102.41592   5"},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.lm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitting Micro-Macro Multilevel Linear Models — micromacro.lm","title":"Fitting Micro-Macro Multilevel Linear Models — micromacro.lm","text":"computing adjusted group means individual-level predictors adjusted.predictors, use micromacro.lm estimation results inferential statistics.","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.lm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitting Micro-Macro Multilevel Linear Models — micromacro.lm","text":"","code":"micromacro.lm(model, adjusted.predictors, y, unequal.groups = NULL)"},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.lm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitting Micro-Macro Multilevel Linear Models — micromacro.lm","text":"model linear regression model formula, e.g., .formula(y ~ x1 + x2 ... + xm). adjusted.predictors G--m data frame, column variables group-level predictors adjusted group means individual-level predictors computed adjusted.predictors function. G denotes number groups m denotes number predictors model. y array G--1 numeric matrix corresponds group-level outcome variable model. unequal.groups optional boolean variable automatically reported adjusted.predictors function. TRUE = group size different across groups; FALSE = group size across groups. Default FALSE (group size).","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.lm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitting Micro-Macro Multilevel Linear Models — micromacro.lm","text":"statistics summary reports standard inferential statistics linear regression, e.g., \"Estimate\", coefficient estimates; \"Uncorrected S.E.\"/\"S.E.\", OLS standard errors; \"Corrected S.E.\", heteroskedasticity-consistent standard errors; \"df\", degree freedom; \"t\", Student t statistics; \"Pr(>|t|)\", two-sided p-value; \"r\", effect size. rsquared r squared. rsquared.adjusted adjusted r squared. residuals residuals model. fitted.values fitted values model. fstatistic F statistics model. model.formula model formula.","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.lm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fitting Micro-Macro Multilevel Linear Models — micromacro.lm","text":"date, multilevel methodologies can unbiasedly model macro-micro multilevel situations, wherein group-level predictors (e.g., city temperature) used predict individual-level outcome variable (e.g., citizen personality). contrast, R package enables researchers model micro-macro situations, wherein individual-level (micro) predictors (group-level predictors) used predict group-level (macro) outcome variable unbiased way. conduct micro-macro multilevel modeling current package, one must first compute adjusted group means function adjusted.predictors. micro-macro multilevel modeling, statistically biased directly regress group-level outcome variable unadjusted group means individual-level predictors (Croon & van Veldhoven, 2007). Instead, one use best linear unbiased predictors (BLUP) group means (.e., adjusted group means), conveniently computed adjusted.predictors. produced adjusted.predictors, adjusted group means can used one inputs micromacro.lm function, reports estimation results inferential statistics micro-macro multilevel model interest. group size across groups (.e., unequal.groups = FALSE), OLS standard errors reported used determine inferential statistics micro-macro model. group size different across groups (.e., unequal.groups = TRUE), however, heteroscedasticity-consistent standard errors reported used determine inferential statistics micro-macro model (White, 1980).","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.lm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fitting Micro-Macro Multilevel Linear Models — micromacro.lm","text":"Akinola, M., Page-Gould, E., Mehta, P. H., & Lu, J. G. (2016). Collective hormonal profiles predict group performance. Proceedings National Academy Sciences, 113 (35), 9774-9779. Croon, M. ., & van Veldhoven, M. J. (2007). Predicting group-level outcome variables variables measured individual level: latent variable multilevel model. Psychological Methods, 12(1), 45-57. White, H. (1980). heteroskedasticity-consistent covariance estimator direct test heteroskedasticity. Econometrica, 48, 817-838.","code":""},{"path":[]},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.lm.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Fitting Micro-Macro Multilevel Linear Models — micromacro.lm","text":"Jackson G. Lu, Elizabeth Page-Gould, & Nancy R. Xu (maintainer, nancyranxu@gmail.com).","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.lm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitting Micro-Macro Multilevel Linear Models — micromacro.lm","text":"","code":"######## SETUP: DATA GENERATING PROCESSES ######## set.seed(123) # Step 1. Generate a G-by-q data frame of group-level predictors (e.g., control variables), z.data # In this example, G = 40, q = 2 group.id = seq(1, 40) z.var1 = rnorm(40, mean=0, sd=1) z.var2 = rnorm(40, mean=100, sd=2) z.data = data.frame(group.id, z.var1, z.var2) # Step 2. Generate a G-by-p data frame of group-level means for the predictors that will be used to # generate x.data # In this example, there are 3 individual-level predictors, thus p = 3 x.var1.means = rnorm(40, mean=50, sd = .05) x.var2.means = rnorm(40, mean=20, sd = .05) x.var3.means = rnorm(40, mean=-10, sd = .05) x.data.means = data.frame(group.id, x.var1.means, x.var2.means, x.var3.means) # Step 3. Generate two N-by-p data frames of individual-level predictors, x.data # One of these two data frames assumes unequal-sized groups (Step 3a), whereas the other assumes # equal-sized groups (Step 3b): # Step 3a. Generate the individual-level predictors # In this example, N = 200 and group size is unequal x.data.unequal = data.frame( group.id=rep(1:40, times=sample( c(4,5,6), 40, replace=TRUE) )[1:200] ) x.data.unequal = merge( x.data.unequal,                 data.frame( group.id, x.var1.means, x.var2.means, x.var3.means ), by=\"group.id\" ) x.data.unequal = within( x.data.unequal, {   x.var1 = x.var1.means + rnorm(200, mean=0, sd = 2)   x.var2 = x.var2.means + rnorm(200, mean=0, sd = 6)   x.var3 = x.var3.means + rnorm(200, mean=0, sd = 1.5) }) # Step 3b. Generate the individual-level predictors # In this example, N = 200 and group size is equal x.data.equal = data.frame( group.id=rep(1:40, each=5) ) x.data.equal = merge( x.data.equal, x.data.means, by=\"group.id\" ) x.data.equal = within( x.data.equal, {   x.var1 = x.var1.means + rnorm(200, mean=0, sd = 2)   x.var2 = x.var2.means + rnorm(200, mean=0, sd = 6)   x.var3 = x.var3.means + rnorm(200, mean=0, sd = 1.5) }) # Step 3. Generate a G-by-1 data frame of group-level outcome variable, y # In this example, G = 40 y = rnorm(40, mean=6, sd=5)  apply(x.data.equal,2,mean) #>     group.id x.var1.means x.var2.means x.var3.means       x.var3       x.var2  #>    20.500000    50.000393    19.994708    -9.999167    -9.955875    19.871931  #>       x.var1  #>    50.138110  #    group.id x.var1.means x.var2.means x.var3.means       x.var3       x.var2       x.var1 # 20.500000    50.000393    19.994708    -9.999167   -10.031995    20.185361    50.084635 apply(x.data.unequal,2,mean) #>     group.id x.var1.means x.var2.means x.var3.means       x.var3       x.var2  #>     20.38000     50.00119     19.99384    -10.00026     -9.99205     20.07592  #>       x.var1  #>     50.04153  #    group.id x.var1.means x.var2.means x.var3.means       x.var3       x.var2       x.var1 # 20.460000    50.002286    19.994605    -9.997034    -9.983146    19.986111    50.123591 apply(z.data,2,mean) #>    group.id      z.var1      z.var2  #> 20.50000000  0.04518332 99.98656817  # z.var1      z.var2 # 0.04518332 99.98656817 mean(y) #> [1] 6.355156 # 6.457797  ######## EXAMPLE 1. GROUP SIZE IS DIFFERENT ACROSS GROUPS ######## ######## Need to use adjusted.predictors() in the same package ###  # Step 4a. Generate a G-by-1 matrix of group ID, z.gid. Then generate an N-by-1 matrix of # each individual's group ID, x.gid, where the group sizes are different z.gid = seq(1:40) x.gid = x.data.unequal$group.id # Step 5a. Generate the best linear unbiased predictors that are calcualted from # individual-level data x.data = x.data.unequal[,c(\"x.var1\",\"x.var2\",\"x.var3\")] results = adjusted.predictors(x.data, z.data, x.gid, z.gid) # Note: Given the fixed random seed, the output should be as below results$unequal.groups #> [1] TRUE # TRUE names(results$adjusted.group.means) #> [1] \"BLUP.x.var1\" \"BLUP.x.var2\" \"BLUP.x.var3\" \"group.id\"    \"z.var1\"      #> [6] \"z.var2\"      \"gid\"         # \"BLUP.x.var1\" \"BLUP.x.var2\" \"BLUP.x.var3\" \"z.var1\"      \"z.var2\"      \"gid\" head(results$adjusted.group.means) #>   BLUP.x.var1 BLUP.x.var2 BLUP.x.var3 group.id      z.var1    z.var2 gid #> 1    50.26217    22.87471  -10.269459        1 -0.56047565  98.61059   1 #> 2    50.07401    19.27554  -10.212717        2 -0.23017749  99.58417   2 #> 3    49.41058    18.73552  -10.503523        3  1.55870831  97.46921   3 #> 4    50.16042    21.18500   -9.739461        4  0.07050839 104.33791   4 #> 5    50.08519    20.34232   -9.922236        5  0.12928774 102.41592   5 #> 6    50.02981    21.47008  -10.419274        6  1.71506499  97.75378   6 #   BLUP.x.var1 BLUP.x.var2 BLUP.x.var3 group.id      z.var1    z.var2 gid # 1    50.05308    20.83911  -10.700361        1 -0.56047565  98.61059   1 # 2    48.85559    22.97411   -9.957270        2 -0.23017749  99.58417   2 # 3    50.16357    19.50001   -9.645735        3  1.55870831  97.46921   3 # 4    49.61853    21.25962  -10.459398        4  0.07050839 104.33791   4 # 5    50.49673    21.38353   -9.789924        5  0.12928774 102.41592   5 # 6    50.86154    19.15901   -9.245675        6  1.71506499  97.75378   6 # Step 6a. Fit a micro-macro multilevel model when group sizes are different model.formula = as.formula(y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2) model.output = micromacro.lm(model.formula, results$adjusted.group.means, y, results$unequal.groups) micromacro.summary(model.output) #> Call: #> micromacro.lm( y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2, ...) #>      #> Residuals: #>        Min        1Q   Median       3Q      Max #>  -12.44995 -3.072524 1.136993 3.060846 7.729297 #>  #>      #> Coefficients: #>               Estimate Uncorrected S.E. Corrected S.E. df            t #> (Intercept) -1.3299870      120.8224341    140.7750489 34 -0.009447605 #> BLUP.x.var1 -0.3202957        2.7007507      3.2420864 34 -0.098793087 #> BLUP.x.var2 -0.8821558        0.6467677      0.6629507 34 -1.330650798 #> BLUP.x.var3  0.2105126        2.0181463      2.2341163 34  0.094226322 #> z.var1       0.4438533        1.5545090      1.5529317 34  0.285816340 #> z.var2       0.4349744        0.4958303      0.4142799 34  1.049953032 #>              Pr(>|t|)           r #> (Intercept) 0.9925172 0.001620249 #> BLUP.x.var1 0.9218827 0.016940443 #> BLUP.x.var2 0.1921598 0.222485030 #> BLUP.x.var3 0.9254825 0.016157571 #> z.var1      0.7767530 0.048958318 #> z.var2      0.3011458 0.177215399 #>  #> --- #> Residual standard error: 5.01671 on 34 degrees of freedom #> Multiple R-squared: 0.1025492268, Adjusted R-squared: -0.0294288281 #> F-statistic: 0.77702 on 5 and 34 DF, p-value: 0.57313 # Call: #   micromacro.lm( y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2, ...) # # Residuals: #        Min        1Q  Median       3Q      Max # -13.41505 -2.974074 1.13077 3.566021 6.975819 # # # Coefficients: #           Estimate  Uncorrected S.E. Corrected S.E. df          t  Pr(>|t|)          r # (Intercept) 78.1232185    121.5103390  122.1367432 34  0.6396373 0.5266952 0.10904278 # BLUP.x.var1 -0.7589602      1.4954434    1.7177575 34 -0.4418320 0.6614084 0.07555696 # BLUP.x.var2  0.4263309      0.7070773    0.6299759 34  0.6767416 0.5031484 0.11528637 # BLUP.x.var3  0.2658078      2.4662049    2.4051691 34  0.1105152 0.9126506 0.01894980 # z.var1       0.4315941      1.0855707    1.0614535 34  0.4066068 0.6868451 0.06956356 # z.var2      -0.3949955      0.5573789    0.4230256 34 -0.9337390 0.3570228 0.15812040 # # --- #   Residual standard error: 5.1599 on 34 degrees of freedom # Multiple R-squared: 0.0400727607, Adjusted R-squared: -0.1010930098 # F-statistic: 0.28387 on 5 and 34 DF, p-value: 0.91869  model.output$statistics #>               Estimate Uncorrected S.E. Corrected S.E. df            t #> (Intercept) -1.3299870      120.8224341    140.7750489 34 -0.009447605 #> BLUP.x.var1 -0.3202957        2.7007507      3.2420864 34 -0.098793087 #> BLUP.x.var2 -0.8821558        0.6467677      0.6629507 34 -1.330650798 #> BLUP.x.var3  0.2105126        2.0181463      2.2341163 34  0.094226322 #> z.var1       0.4438533        1.5545090      1.5529317 34  0.285816340 #> z.var2       0.4349744        0.4958303      0.4142799 34  1.049953032 #>              Pr(>|t|)           r #> (Intercept) 0.9925172 0.001620249 #> BLUP.x.var1 0.9218827 0.016940443 #> BLUP.x.var2 0.1921598 0.222485030 #> BLUP.x.var3 0.9254825 0.016157571 #> z.var1      0.7767530 0.048958318 #> z.var2      0.3011458 0.177215399 #           Estimate  Uncorrected S.E. Corrected S.E. df          t  Pr(>|t|)          r # (Intercept) 78.1232185    121.5103390  122.1367432 34  0.6396373 0.5266952 0.10904278 # BLUP.x.var1 -0.7589602      1.4954434    1.7177575 34 -0.4418320 0.6614084 0.07555696 # BLUP.x.var2  0.4263309      0.7070773    0.6299759 34  0.6767416 0.5031484 0.11528637 # BLUP.x.var3  0.2658078      2.4662049    2.4051691 34  0.1105152 0.9126506 0.01894980 # z.var1       0.4315941      1.0855707    1.0614535 34  0.4066068 0.6868451 0.06956356 # z.var2      -0.3949955      0.5573789    0.4230256 34 -0.9337390 0.3570228 0.15812040 model.output$rsquared #> [1] 0.1025492 # 0.0400727607 model.output$rsquared.adjusted #> [1] -0.02942883 # -0.1010930098  ######## EXAMPLE 2. GROUP SIZE IS THE SAME ACROSS ALL GROUPS ######## ######## Need to use adjusted.predictors() in the same package ######  # Step 4b. Generate a G-by-1 matrix of group ID, z.gid. Then generate an N-by-1 matrix of # each individual's group ID, x.gid, where group size is the same across all groups z.gid = seq(1:40) x.gid = x.data.equal$group.id # Step 5b. Generate the best linear unbiased predictors that are calcualted from # individual-level data x.data = x.data.equal[,c(\"x.var1\",\"x.var2\",\"x.var3\")] results = adjusted.predictors(x.data, z.data, x.gid, z.gid) results$unequal.groups #> [1] FALSE # FALSE names(results$adjusted.group.means) #> [1] \"BLUP.x.var1\" \"BLUP.x.var2\" \"BLUP.x.var3\" \"group.id\"    \"z.var1\"      #> [6] \"z.var2\"      \"gid\"         # \"BLUP.x.var1\" \"BLUP.x.var2\" \"BLUP.x.var3\" \"z.var1\"      \"z.var2\"      \"gid\" results$adjusted.group.means[1:5, ] #>   BLUP.x.var1 BLUP.x.var2 BLUP.x.var3 group.id      z.var1    z.var2 gid #> 1    49.76696    21.68605  -10.035639        1 -0.56047565  98.61059   1 #> 2    49.90570    19.91467   -9.625758        2 -0.23017749  99.58417   2 #> 3    50.03031    20.76583  -11.141062        3  1.55870831  97.46921   3 #> 4    50.27814    21.22401   -9.068284        4  0.07050839 104.33791   4 #> 5    50.11567    19.13808   -9.882101        5  0.12928774 102.41592   5 #   BLUP.x.var1 BLUP.x.var2 BLUP.x.var3 group.id      z.var1    z.var2 gid # 1    50.91373    19.12994  -10.051647        1 -0.56047565  98.61059   1 # 2    50.19068    19.17978  -10.814382        2 -0.23017749  99.58417   2 # 3    50.13390    20.98893   -9.952348        3  1.55870831  97.46921   3 # 4    49.68169    19.60632  -10.612717        4  0.07050839 104.33791   4 # 5    50.28579    22.07469  -10.245505        5  0.12928774 102.41592   5 # Step 6b. Fit a micro-macro multilevel model when group size is the same across groups model.output2 = micromacro.lm(model.formula, results$adjusted.group.means, y,                               results$unequal.groups) micromacro.summary(model.output2) #> Call: #> micromacro.lm( y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2, ...) #>      #> Residuals: #>        Min       1Q   Median       3Q      Max #>  -13.98453 -3.00747 1.610605 3.430856 8.685289 #>  #>      #> Coefficients: #>                 Estimate        S.E. df            t  Pr(>|t|)           r #> (Intercept) 58.478128479 166.1848267 34  0.351886088 0.7270954 0.060238375 #> BLUP.x.var1 -0.875541328   2.2525208 34 -0.388693996 0.6999260 0.066512855 #> BLUP.x.var2  0.004557453   0.7455256 34  0.006113074 0.9951582 0.001048383 #> BLUP.x.var3  0.788519540   1.9137741 34  0.412023319 0.6829086 0.070485667 #> z.var1       1.265213986   1.0488902 34  1.206240695 0.2360515 0.202579330 #> z.var2      -0.005223853   0.6054511 34 -0.008628034 0.9931663 0.001479694 #>  #> --- #> Residual standard error: 5.16752 on 34 degrees of freedom #> Multiple R-squared: 0.0477812405, Adjusted R-squared: -0.0922509301 #> F-statistic: 0.34122 on 5 and 34 DF, p-value: 0.88426 # Call: #   micromacro.lm( y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2, ...) # # Residuals: #        Min        1Q    Median      3Q      Max # -12.94409 -1.898937 0.8615494 3.78739 8.444582 # # # Coefficients: #                Estimate         S.E. df          t  Pr(>|t|)          r # (Intercept) 135.4109966 134.1478457 34  1.0094161 0.3199052 0.17057636 # BLUP.x.var1  -2.1984308   2.2203278 34 -0.9901379 0.3291012 0.16741080 # BLUP.x.var2  -0.6369600   0.8619558 34 -0.7389706 0.4649961 0.12572678 # BLUP.x.var3  -0.5121002   1.7889594 34 -0.2862559 0.7764192 0.04903343 # z.var1        0.7718147   1.1347170 34  0.6801826 0.5009945 0.11586471 # z.var2       -0.1116209   0.5268130 34 -0.2118795 0.8334661 0.03631307 # # --- #   Residual standard error: 5.11849 on 34 degrees of freedom # Multiple R-squared: 0.0554183804, Adjusted R-squared: -0.0834906813 # F-statistic: 0.39895 on 5 and 34 DF, p-value: 0.84607  model.output2$statistics #>                 Estimate        S.E. df            t  Pr(>|t|)           r #> (Intercept) 58.478128479 166.1848267 34  0.351886088 0.7270954 0.060238375 #> BLUP.x.var1 -0.875541328   2.2525208 34 -0.388693996 0.6999260 0.066512855 #> BLUP.x.var2  0.004557453   0.7455256 34  0.006113074 0.9951582 0.001048383 #> BLUP.x.var3  0.788519540   1.9137741 34  0.412023319 0.6829086 0.070485667 #> z.var1       1.265213986   1.0488902 34  1.206240695 0.2360515 0.202579330 #> z.var2      -0.005223853   0.6054511 34 -0.008628034 0.9931663 0.001479694 #                Estimate         S.E. df          t  Pr(>|t|)          r # (Intercept) 135.4109966 134.1478457 34  1.0094161 0.3199052 0.17057636 # BLUP.x.var1  -2.1984308   2.2203278 34 -0.9901379 0.3291012 0.16741080 # BLUP.x.var2  -0.6369600   0.8619558 34 -0.7389706 0.4649961 0.12572678 # BLUP.x.var3  -0.5121002   1.7889594 34 -0.2862559 0.7764192 0.04903343 # z.var1        0.7718147   1.1347170 34  0.6801826 0.5009945 0.11586471 # z.var2       -0.1116209   0.5268130 34 -0.2118795 0.8334661 0.03631307 model.output2$rsquared #> [1] 0.04778124 # 0.0554183804 model.output2$rsquared.adjusted #> [1] -0.09225093 # -0.0834906813  ######## EXAMPLE 3 (after EXAMPLE 2). ADDING A MICRO-MICRO INTERACTION TERM ######## model.formula3 = as.formula(y ~ BLUP.x.var1 * BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2) model.output3 = micromacro.lm(model.formula3, results$adjusted.group.means, y,                               results$unequal.groups) micromacro.summary(model.output3) #> Call: #> micromacro.lm( y ~ BLUP.x.var1 * BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2, ...) #>      #> Residuals: #>        Min        1Q   Median       3Q      Max #>  -14.03965 -3.061697 1.708925 3.492015 8.497856 #>  #>      #> Coefficients: #>                              Estimate         S.E. df            t  Pr(>|t|) #> (Intercept)             -3.705789e+02 1610.5294900 33 -0.230097569 0.8194364 #> BLUP.x.var1              7.644314e+00   31.8869271 33  0.239731909 0.8120210 #> BLUP.x.var2              2.166514e+01   80.8635210 33  0.267922269 0.7904268 #> BLUP.x.var3              8.236089e-01    1.9448619 33  0.423479363 0.6746930 #> z.var1                   1.221233e+00    1.0761068 33  1.134862263 0.2646092 #> z.var2                   4.283912e-03    0.6149142 33  0.006966682 0.9944834 #> BLUP.x.var1:BLUP.x.var2 -4.306982e-01    1.6078172 33 -0.267877614 0.7904608 #>                                   r #> (Intercept)             0.040022752 #> BLUP.x.var1             0.041695677 #> BLUP.x.var2             0.046588638 #> BLUP.x.var3             0.073518801 #> z.var1                  0.193808416 #> z.var2                  0.001212743 #> BLUP.x.var1:BLUP.x.var2 0.046580890 #>  #> --- #> Residual standard error: 5.16191 on 33 degrees of freedom #> Multiple R-squared: 0.049847345, Adjusted R-squared: -0.1229076832 #> F-statistic: 0.28854 on 6 and 33 DF, p-value: 0.93819 # Call: #   micromacro.lm( y ~ BLUP.x.var1 * BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2, ...) # # Residuals: #        Min        1Q    Median       3Q      Max # -13.21948 -2.048324 0.7062639 3.843816 7.924922 # # # Coefficients: #                              Estimate         S.E. df          t  Pr(>|t|)          r # (Intercept)             -1.098875e+03 1962.9182021 33 -0.5598169 0.5793848 0.09699214 # BLUP.x.var1              2.231877e+01   38.9620284 33  0.5728339 0.5706400 0.09922547 # BLUP.x.var2              5.988568e+01   96.0256433 33  0.6236426 0.5371496 0.10792809 # BLUP.x.var3             -9.557605e-01    1.9374178 33 -0.4933167 0.6250560 0.08556050 # z.var1                   6.116347e-01    1.1727757 33  0.5215274 0.6054822 0.09041443 # z.var2                  -8.556163e-02    0.5331509 33 -0.1604829 0.8734790 0.02792560 # BLUP.x.var1:BLUP.x.var2 -1.209354e+00    1.9186909 33 -0.6303016 0.5328380 0.10906688 # # --- #   Residual standard error: 5.08795 on 33 degrees of freedom # Multiple R-squared: 0.0666547309, Adjusted R-squared: -0.103044409 # F-statistic: 0.39278 on 6 and 33 DF, p-value: 0.87831  model.output3$statistics #>                              Estimate         S.E. df            t  Pr(>|t|) #> (Intercept)             -3.705789e+02 1610.5294900 33 -0.230097569 0.8194364 #> BLUP.x.var1              7.644314e+00   31.8869271 33  0.239731909 0.8120210 #> BLUP.x.var2              2.166514e+01   80.8635210 33  0.267922269 0.7904268 #> BLUP.x.var3              8.236089e-01    1.9448619 33  0.423479363 0.6746930 #> z.var1                   1.221233e+00    1.0761068 33  1.134862263 0.2646092 #> z.var2                   4.283912e-03    0.6149142 33  0.006966682 0.9944834 #> BLUP.x.var1:BLUP.x.var2 -4.306982e-01    1.6078172 33 -0.267877614 0.7904608 #>                                   r #> (Intercept)             0.040022752 #> BLUP.x.var1             0.041695677 #> BLUP.x.var2             0.046588638 #> BLUP.x.var3             0.073518801 #> z.var1                  0.193808416 #> z.var2                  0.001212743 #> BLUP.x.var1:BLUP.x.var2 0.046580890 #                              Estimate         S.E. df          t  Pr(>|t|)          r # (Intercept)             -1.098875e+03 1962.9182021 33 -0.5598169 0.5793848 0.09699214 # BLUP.x.var1              2.231877e+01   38.9620284 33  0.5728339 0.5706400 0.09922547 # BLUP.x.var2              5.988568e+01   96.0256433 33  0.6236426 0.5371496 0.10792809 # BLUP.x.var3             -9.557605e-01    1.9374178 33 -0.4933167 0.6250560 0.08556050 # z.var1                   6.116347e-01    1.1727757 33  0.5215274 0.6054822 0.09041443 # z.var2                  -8.556163e-02    0.5331509 33 -0.1604829 0.8734790 0.02792560 # BLUP.x.var1:BLUP.x.var2 -1.209354e+00    1.9186909 33 -0.6303016 0.5328380 0.10906688 model.output3$rsquared #> [1] 0.04984734 # 0.0666547309 model.output3$rsquared.adjusted #> [1] -0.1229077 # -0.103044409  ######## EXAMPLE 4 (after EXAMPLE 2). ADDING A MICRO-MACRO INTERACTION TERM ######## model.formula4 = as.formula(y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 * z.var1 + z.var2) model.output4 = micromacro.lm(model.formula4, results$adjusted.group.means, y,                               results$unequal.groups) micromacro.summary(model.output4) #> Call: #> micromacro.lm( y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 * z.var1 + z.var2, ...) #>      #> Residuals: #>        Min       1Q   Median      3Q      Max #>  -13.84927 -2.95845 1.440022 2.82892 8.830067 #>  #>      #> Coefficients: #>                        Estimate        S.E. df           t  Pr(>|t|)          r #> (Intercept)         73.68055147 163.4923949 33  0.45066654 0.6551771 0.07821067 #> BLUP.x.var1         -0.89383225   2.2118241 33 -0.40411543 0.6887350 0.07017404 #> BLUP.x.var2         -0.04708330   0.7328492 33 -0.06424692 0.9491612 0.01118325 #> BLUP.x.var3          1.19583378   1.8985690 33  0.62986057 0.5331230 0.10899146 #> z.var1             -24.78249408  17.3429303 33 -1.42896810 0.1624116 0.24139507 #> z.var2              -0.09907994   0.5977671 33 -0.16575008 0.8693649 0.02884138 #> BLUP.x.var3:z.var1  -2.60917315   1.7341582 33 -1.50457624 0.1419449 0.25336694 #>  #> --- #> Residual standard error: 4.99891 on 33 degrees of freedom #> Multiple R-squared: 0.1089087413, Adjusted R-squared: -0.0531078512 #> F-statistic: 0.67221 on 6 and 33 DF, p-value: 0.67273 # Call: #   micromacro.lm( y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 * z.var1 + z.var2, ...) # # Residuals: #        Min        1Q    Median       3Q     Max # -12.99937 -1.909645 0.8775397 3.712013 8.46591 # # # Coefficients: #                       Estimate         S.E. df          t  Pr(>|t|)          r # (Intercept)        129.22731579 146.4817031 33  0.8822079 0.3840456 0.15179313 # BLUP.x.var1         -2.10556192   2.3951160 33 -0.8791064 0.3857003 0.15127172 # BLUP.x.var2         -0.63762927   0.8747645 33 -0.7289153 0.4711953 0.12587857 # BLUP.x.var3         -0.53590189   1.8273917 33 -0.2932605 0.7711594 0.05098372 # z.var1               2.95426548  19.1170600 33  0.1545356 0.8781288 0.02689146 # z.var2              -0.09852267   0.5467583 33 -0.1801942 0.8581021 0.03135236 # BLUP.x.var3:z.var1   0.21489002   1.8788995 33  0.1143702 0.9096374 0.01990534 # # --- #   Residual standard error: 5.11747 on 33 degrees of freedom # Multiple R-squared: 0.0557926451, Adjusted R-squared: -0.1158814195 # F-statistic: 0.32499 on 6 and 33 DF, p-value: 0.91909  model.output4$statistics #>                        Estimate        S.E. df           t  Pr(>|t|)          r #> (Intercept)         73.68055147 163.4923949 33  0.45066654 0.6551771 0.07821067 #> BLUP.x.var1         -0.89383225   2.2118241 33 -0.40411543 0.6887350 0.07017404 #> BLUP.x.var2         -0.04708330   0.7328492 33 -0.06424692 0.9491612 0.01118325 #> BLUP.x.var3          1.19583378   1.8985690 33  0.62986057 0.5331230 0.10899146 #> z.var1             -24.78249408  17.3429303 33 -1.42896810 0.1624116 0.24139507 #> z.var2              -0.09907994   0.5977671 33 -0.16575008 0.8693649 0.02884138 #> BLUP.x.var3:z.var1  -2.60917315   1.7341582 33 -1.50457624 0.1419449 0.25336694 #                       Estimate         S.E. df          t  Pr(>|t|)          r # (Intercept)        129.22731579 146.4817031 33  0.8822079 0.3840456 0.15179313 # BLUP.x.var1         -2.10556192   2.3951160 33 -0.8791064 0.3857003 0.15127172 # BLUP.x.var2         -0.63762927   0.8747645 33 -0.7289153 0.4711953 0.12587857 # BLUP.x.var3         -0.53590189   1.8273917 33 -0.2932605 0.7711594 0.05098372 # z.var1               2.95426548  19.1170600 33  0.1545356 0.8781288 0.02689146 # z.var2              -0.09852267   0.5467583 33 -0.1801942 0.8581021 0.03135236 # BLUP.x.var3:z.var1   0.21489002   1.8788995 33  0.1143702 0.9096374 0.01990534 model.output4$rsquared #> [1] 0.1089087 # 0.0557926451 model.output4$rsquared.adjusted #> [1] -0.05310785 # -0.1158814195"},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarizing the Micro-Macro Multilevel Linear Model Fitting Results — micromacro.summary","title":"Summarizing the Micro-Macro Multilevel Linear Model Fitting Results — micromacro.summary","text":"fitting micro-macro multilevel model, function produces user-friendly summary table results.","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarizing the Micro-Macro Multilevel Linear Model Fitting Results — micromacro.summary","text":"","code":"micromacro.summary(model.output)"},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarizing the Micro-Macro Multilevel Linear Model Fitting Results — micromacro.summary","text":"model.output output micromacro.lm contains model results model specifications.","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarizing the Micro-Macro Multilevel Linear Model Fitting Results — micromacro.summary","text":"table summary table.","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.summary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarizing the Micro-Macro Multilevel Linear Model Fitting Results — micromacro.summary","text":"date, multilevel methodologies can unbiasedly model macro-micro multilevel situations, wherein group-level predictors (e.g., city temperature) used predict individual-level outcome variable (e.g., citizen personality). contrast, R package enables researchers model micro-macro situations, wherein individual-level (micro) predictors (group-level predictors) used predict group-level (macro) outcome variable unbiased way. conduct micro-macro multilevel modeling current package, one must first compute adjusted group means function adjusted.predictors. micro-macro multilevel modeling, statistically biased directly regress group-level outcome variable unadjusted group means individual-level predictors (Croon & van Veldhoven, 2007). Instead, one use best linear unbiased predictors (BLUP) group means (.e., adjusted group means), conveniently computed adjusted.predictors. produced adjusted.predictors, adjusted group means can used one inputs micromacro.lm function, reports estimation results inferential statistics micro-macro multilevel model interest. group size across groups (.e., unequal.groups = FALSE), OLS standard errors reported used determine inferential statistics micro-macro model. group size different across groups (.e., unequal.groups = TRUE), however, heteroscedasticity-consistent standard errors reported used determine inferential statistics micro-macro model (White, 1980). micromacro.summary produces detailed summary model fitting specifications, given outputs micromacro.lm.","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.summary.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Summarizing the Micro-Macro Multilevel Linear Model Fitting Results — micromacro.summary","text":"Akinola, M., Page-Gould, E., Mehta, P. H., & Lu, J. G. (2016). Collective hormonal profiles predict group performance. Proceedings National Academy Sciences, 113 (35), 9774-9779. Croon, M. ., & van Veldhoven, M. J. (2007). Predicting group-level outcome variables variables measured individual level: latent variable multilevel model. Psychological methods, 12(1), 45-57.","code":""},{"path":[]},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.summary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summarizing the Micro-Macro Multilevel Linear Model Fitting Results — micromacro.summary","text":"Jackson G. Lu, Elizabeth Page-Gould, Nancy R. Xu (maintainer, nancyranxu@gmail.com).","code":""},{"path":"https://jrdnbradford.github.io/MicroMacroMultilevel/reference/micromacro.summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarizing the Micro-Macro Multilevel Linear Model Fitting Results — micromacro.summary","text":"","code":"######## SETUP: DATA GENERATING PROCESSES ######## set.seed(123) # Step 1. Generate a G-by-q data frame of group-level predictors (e.g., control variables), z.data # In this example, G = 40, q = 2 group.id = seq(1, 40) z.var1 = rnorm(40, mean=0, sd=1) z.var2 = rnorm(40, mean=100, sd=2) z.data = data.frame(group.id, z.var1, z.var2) # Step 2. Generate a G-by-p data frame of group-level means for the predictors that will be used to # generate x.data # In this example, there are 3 individual-level predictors, thus p = 3 x.var1.means = rnorm(40, mean=50, sd = .05) x.var2.means = rnorm(40, mean=20, sd = .05) x.var3.means = rnorm(40, mean=-10, sd = .05) x.data.means = data.frame(group.id, x.var1.means, x.var2.means, x.var3.means) # Step 3. Generate two N-by-p data frames of individual-level predictors, x.data # One of these two data frames assumes unequal-sized groups (Step 3a), whereas the other assumes # equal-sized groups (Step 3b): # Step 3a. Generate the individual-level predictors # In this example, N = 200 and group size is unequal x.data.unequal = data.frame( group.id=rep(1:40, times=sample( c(4,5,6), 40, replace=TRUE) )[1:200] ) x.data.unequal = merge( x.data.unequal,                 data.frame( group.id, x.var1.means, x.var2.means, x.var3.means ), by=\"group.id\" ) x.data.unequal = within( x.data.unequal, {   x.var1 = x.var1.means + rnorm(200, mean=0, sd = 2)   x.var2 = x.var2.means + rnorm(200, mean=0, sd = 6)   x.var3 = x.var3.means + rnorm(200, mean=0, sd = 1.5) }) # Step 3b. Generate the individual-level predictors # In this example, N = 200 and group size is equal x.data.equal = data.frame( group.id=rep(1:40, each=5) ) x.data.equal = merge( x.data.equal, x.data.means, by=\"group.id\" ) x.data.equal = within( x.data.equal, {   x.var1 = x.var1.means + rnorm(200, mean=0, sd = 2)   x.var2 = x.var2.means + rnorm(200, mean=0, sd = 6)   x.var3 = x.var3.means + rnorm(200, mean=0, sd = 1.5) }) # Step 3. Generate a G-by-1 data frame of group-level outcome variable, y # In this example, G = 40 y = rnorm(40, mean=6, sd=5)  apply(x.data.equal,2,mean) #>     group.id x.var1.means x.var2.means x.var3.means       x.var3       x.var2  #>    20.500000    50.000393    19.994708    -9.999167    -9.955875    19.871931  #>       x.var1  #>    50.138110  #    group.id x.var1.means x.var2.means x.var3.means       x.var3       x.var2       x.var1 # 20.500000    50.000393    19.994708    -9.999167   -10.031995    20.185361    50.084635 apply(x.data.unequal,2,mean) #>     group.id x.var1.means x.var2.means x.var3.means       x.var3       x.var2  #>     20.38000     50.00119     19.99384    -10.00026     -9.99205     20.07592  #>       x.var1  #>     50.04153  #    group.id x.var1.means x.var2.means x.var3.means       x.var3       x.var2       x.var1 # 20.460000    50.002286    19.994605    -9.997034    -9.983146    19.986111    50.123591 apply(z.data,2,mean) #>    group.id      z.var1      z.var2  #> 20.50000000  0.04518332 99.98656817  # z.var1      z.var2 # 0.04518332 99.98656817 mean(y) #> [1] 6.355156 # 6.457797  ######## EXAMPLE 1. GROUP SIZE IS DIFFERENT ACROSS GROUPS ######## ######## Need to use adjusted.predictors() in the same package ###  # Step 4a. Generate a G-by-1 matrix of group ID, z.gid. Then generate an N-by-1 matrix of # each individual's group ID, x.gid, where the group sizes are different z.gid = seq(1:40) x.gid = x.data.unequal$group.id # Step 5a. Generate the best linear unbiased predictors that are calcualted from # individual-level data x.data = x.data.unequal[,c(\"x.var1\",\"x.var2\",\"x.var3\")] results = adjusted.predictors(x.data, z.data, x.gid, z.gid) # Note: Given the fixed random seed, the output should be as below results$unequal.groups #> [1] TRUE # TRUE names(results$adjusted.group.means) #> [1] \"BLUP.x.var1\" \"BLUP.x.var2\" \"BLUP.x.var3\" \"group.id\"    \"z.var1\"      #> [6] \"z.var2\"      \"gid\"         # \"BLUP.x.var1\" \"BLUP.x.var2\" \"BLUP.x.var3\" \"z.var1\"      \"z.var2\"      \"gid\" head(results$adjusted.group.means) #>   BLUP.x.var1 BLUP.x.var2 BLUP.x.var3 group.id      z.var1    z.var2 gid #> 1    50.26217    22.87471  -10.269459        1 -0.56047565  98.61059   1 #> 2    50.07401    19.27554  -10.212717        2 -0.23017749  99.58417   2 #> 3    49.41058    18.73552  -10.503523        3  1.55870831  97.46921   3 #> 4    50.16042    21.18500   -9.739461        4  0.07050839 104.33791   4 #> 5    50.08519    20.34232   -9.922236        5  0.12928774 102.41592   5 #> 6    50.02981    21.47008  -10.419274        6  1.71506499  97.75378   6 #   BLUP.x.var1 BLUP.x.var2 BLUP.x.var3 group.id      z.var1    z.var2 gid # 1    50.05308    20.83911  -10.700361        1 -0.56047565  98.61059   1 # 2    48.85559    22.97411   -9.957270        2 -0.23017749  99.58417   2 # 3    50.16357    19.50001   -9.645735        3  1.55870831  97.46921   3 # 4    49.61853    21.25962  -10.459398        4  0.07050839 104.33791   4 # 5    50.49673    21.38353   -9.789924        5  0.12928774 102.41592   5 # 6    50.86154    19.15901   -9.245675        6  1.71506499  97.75378   6 # Step 6a. Fit a micro-macro multilevel model when group sizes are different model.formula = as.formula(y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2) model.output = micromacro.lm(model.formula, results$adjusted.group.means, y, results$unequal.groups) micromacro.summary(model.output) #> Call: #> micromacro.lm( y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2, ...) #>      #> Residuals: #>        Min        1Q   Median       3Q      Max #>  -12.44995 -3.072524 1.136993 3.060846 7.729297 #>  #>      #> Coefficients: #>               Estimate Uncorrected S.E. Corrected S.E. df            t #> (Intercept) -1.3299870      120.8224341    140.7750489 34 -0.009447605 #> BLUP.x.var1 -0.3202957        2.7007507      3.2420864 34 -0.098793087 #> BLUP.x.var2 -0.8821558        0.6467677      0.6629507 34 -1.330650798 #> BLUP.x.var3  0.2105126        2.0181463      2.2341163 34  0.094226322 #> z.var1       0.4438533        1.5545090      1.5529317 34  0.285816340 #> z.var2       0.4349744        0.4958303      0.4142799 34  1.049953032 #>              Pr(>|t|)           r #> (Intercept) 0.9925172 0.001620249 #> BLUP.x.var1 0.9218827 0.016940443 #> BLUP.x.var2 0.1921598 0.222485030 #> BLUP.x.var3 0.9254825 0.016157571 #> z.var1      0.7767530 0.048958318 #> z.var2      0.3011458 0.177215399 #>  #> --- #> Residual standard error: 5.01671 on 34 degrees of freedom #> Multiple R-squared: 0.1025492268, Adjusted R-squared: -0.0294288281 #> F-statistic: 0.77702 on 5 and 34 DF, p-value: 0.57313 # Call: #   micromacro.lm( y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2, ...) # # Residuals: #        Min        1Q  Median       3Q      Max # -13.41505 -2.974074 1.13077 3.566021 6.975819 # # # Coefficients: #           Estimate  Uncorrected S.E. Corrected S.E. df          t  Pr(>|t|)          r # (Intercept) 78.1232185    121.5103390  122.1367432 34  0.6396373 0.5266952 0.10904278 # BLUP.x.var1 -0.7589602      1.4954434    1.7177575 34 -0.4418320 0.6614084 0.07555696 # BLUP.x.var2  0.4263309      0.7070773    0.6299759 34  0.6767416 0.5031484 0.11528637 # BLUP.x.var3  0.2658078      2.4662049    2.4051691 34  0.1105152 0.9126506 0.01894980 # z.var1       0.4315941      1.0855707    1.0614535 34  0.4066068 0.6868451 0.06956356 # z.var2      -0.3949955      0.5573789    0.4230256 34 -0.9337390 0.3570228 0.15812040 # # --- #   Residual standard error: 5.1599 on 34 degrees of freedom # Multiple R-squared: 0.0400727607, Adjusted R-squared: -0.1010930098 # F-statistic: 0.28387 on 5 and 34 DF, p-value: 0.91869  model.output$statistics #>               Estimate Uncorrected S.E. Corrected S.E. df            t #> (Intercept) -1.3299870      120.8224341    140.7750489 34 -0.009447605 #> BLUP.x.var1 -0.3202957        2.7007507      3.2420864 34 -0.098793087 #> BLUP.x.var2 -0.8821558        0.6467677      0.6629507 34 -1.330650798 #> BLUP.x.var3  0.2105126        2.0181463      2.2341163 34  0.094226322 #> z.var1       0.4438533        1.5545090      1.5529317 34  0.285816340 #> z.var2       0.4349744        0.4958303      0.4142799 34  1.049953032 #>              Pr(>|t|)           r #> (Intercept) 0.9925172 0.001620249 #> BLUP.x.var1 0.9218827 0.016940443 #> BLUP.x.var2 0.1921598 0.222485030 #> BLUP.x.var3 0.9254825 0.016157571 #> z.var1      0.7767530 0.048958318 #> z.var2      0.3011458 0.177215399 #           Estimate  Uncorrected S.E. Corrected S.E. df          t  Pr(>|t|)          r # (Intercept) 78.1232185    121.5103390  122.1367432 34  0.6396373 0.5266952 0.10904278 # BLUP.x.var1 -0.7589602      1.4954434    1.7177575 34 -0.4418320 0.6614084 0.07555696 # BLUP.x.var2  0.4263309      0.7070773    0.6299759 34  0.6767416 0.5031484 0.11528637 # BLUP.x.var3  0.2658078      2.4662049    2.4051691 34  0.1105152 0.9126506 0.01894980 # z.var1       0.4315941      1.0855707    1.0614535 34  0.4066068 0.6868451 0.06956356 # z.var2      -0.3949955      0.5573789    0.4230256 34 -0.9337390 0.3570228 0.15812040 model.output$rsquared #> [1] 0.1025492 # 0.0400727607 model.output$rsquared.adjusted #> [1] -0.02942883 # -0.1010930098  ######## EXAMPLE 2. GROUP SIZE IS THE SAME ACROSS ALL GROUPS ######## ######## Need to use adjusted.predictors() in the same package ######  # Step 4b. Generate a G-by-1 matrix of group ID, z.gid. Then generate an N-by-1 matrix of # each individual's group ID, x.gid, where group size is the same across all groups z.gid = seq(1:40) x.gid = x.data.equal$group.id # Step 5b. Generate the best linear unbiased predictors that are calcualted from # individual-level data x.data = x.data.equal[,c(\"x.var1\",\"x.var2\",\"x.var3\")] results = adjusted.predictors(x.data, z.data, x.gid, z.gid) results$unequal.groups #> [1] FALSE # FALSE names(results$adjusted.group.means) #> [1] \"BLUP.x.var1\" \"BLUP.x.var2\" \"BLUP.x.var3\" \"group.id\"    \"z.var1\"      #> [6] \"z.var2\"      \"gid\"         # \"BLUP.x.var1\" \"BLUP.x.var2\" \"BLUP.x.var3\" \"z.var1\"      \"z.var2\"      \"gid\" results$adjusted.group.means[1:5, ] #>   BLUP.x.var1 BLUP.x.var2 BLUP.x.var3 group.id      z.var1    z.var2 gid #> 1    49.76696    21.68605  -10.035639        1 -0.56047565  98.61059   1 #> 2    49.90570    19.91467   -9.625758        2 -0.23017749  99.58417   2 #> 3    50.03031    20.76583  -11.141062        3  1.55870831  97.46921   3 #> 4    50.27814    21.22401   -9.068284        4  0.07050839 104.33791   4 #> 5    50.11567    19.13808   -9.882101        5  0.12928774 102.41592   5 #   BLUP.x.var1 BLUP.x.var2 BLUP.x.var3 group.id      z.var1    z.var2 gid # 1    50.91373    19.12994  -10.051647        1 -0.56047565  98.61059   1 # 2    50.19068    19.17978  -10.814382        2 -0.23017749  99.58417   2 # 3    50.13390    20.98893   -9.952348        3  1.55870831  97.46921   3 # 4    49.68169    19.60632  -10.612717        4  0.07050839 104.33791   4 # 5    50.28579    22.07469  -10.245505        5  0.12928774 102.41592   5 # Step 6b. Fit a micro-macro multilevel model when group size is the same across groups model.output2 = micromacro.lm(model.formula, results$adjusted.group.means, y,                               results$unequal.groups) micromacro.summary(model.output2) #> Call: #> micromacro.lm( y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2, ...) #>      #> Residuals: #>        Min       1Q   Median       3Q      Max #>  -13.98453 -3.00747 1.610605 3.430856 8.685289 #>  #>      #> Coefficients: #>                 Estimate        S.E. df            t  Pr(>|t|)           r #> (Intercept) 58.478128479 166.1848267 34  0.351886088 0.7270954 0.060238375 #> BLUP.x.var1 -0.875541328   2.2525208 34 -0.388693996 0.6999260 0.066512855 #> BLUP.x.var2  0.004557453   0.7455256 34  0.006113074 0.9951582 0.001048383 #> BLUP.x.var3  0.788519540   1.9137741 34  0.412023319 0.6829086 0.070485667 #> z.var1       1.265213986   1.0488902 34  1.206240695 0.2360515 0.202579330 #> z.var2      -0.005223853   0.6054511 34 -0.008628034 0.9931663 0.001479694 #>  #> --- #> Residual standard error: 5.16752 on 34 degrees of freedom #> Multiple R-squared: 0.0477812405, Adjusted R-squared: -0.0922509301 #> F-statistic: 0.34122 on 5 and 34 DF, p-value: 0.88426 # Call: #   micromacro.lm( y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2, ...) # # Residuals: #        Min        1Q    Median      3Q      Max # -12.94409 -1.898937 0.8615494 3.78739 8.444582 # # # Coefficients: #                Estimate         S.E. df          t  Pr(>|t|)          r # (Intercept) 135.4109966 134.1478457 34  1.0094161 0.3199052 0.17057636 # BLUP.x.var1  -2.1984308   2.2203278 34 -0.9901379 0.3291012 0.16741080 # BLUP.x.var2  -0.6369600   0.8619558 34 -0.7389706 0.4649961 0.12572678 # BLUP.x.var3  -0.5121002   1.7889594 34 -0.2862559 0.7764192 0.04903343 # z.var1        0.7718147   1.1347170 34  0.6801826 0.5009945 0.11586471 # z.var2       -0.1116209   0.5268130 34 -0.2118795 0.8334661 0.03631307 # # --- #   Residual standard error: 5.11849 on 34 degrees of freedom # Multiple R-squared: 0.0554183804, Adjusted R-squared: -0.0834906813 # F-statistic: 0.39895 on 5 and 34 DF, p-value: 0.84607  model.output2$statistics #>                 Estimate        S.E. df            t  Pr(>|t|)           r #> (Intercept) 58.478128479 166.1848267 34  0.351886088 0.7270954 0.060238375 #> BLUP.x.var1 -0.875541328   2.2525208 34 -0.388693996 0.6999260 0.066512855 #> BLUP.x.var2  0.004557453   0.7455256 34  0.006113074 0.9951582 0.001048383 #> BLUP.x.var3  0.788519540   1.9137741 34  0.412023319 0.6829086 0.070485667 #> z.var1       1.265213986   1.0488902 34  1.206240695 0.2360515 0.202579330 #> z.var2      -0.005223853   0.6054511 34 -0.008628034 0.9931663 0.001479694 #                Estimate         S.E. df          t  Pr(>|t|)          r # (Intercept) 135.4109966 134.1478457 34  1.0094161 0.3199052 0.17057636 # BLUP.x.var1  -2.1984308   2.2203278 34 -0.9901379 0.3291012 0.16741080 # BLUP.x.var2  -0.6369600   0.8619558 34 -0.7389706 0.4649961 0.12572678 # BLUP.x.var3  -0.5121002   1.7889594 34 -0.2862559 0.7764192 0.04903343 # z.var1        0.7718147   1.1347170 34  0.6801826 0.5009945 0.11586471 # z.var2       -0.1116209   0.5268130 34 -0.2118795 0.8334661 0.03631307 model.output2$rsquared #> [1] 0.04778124 # 0.0554183804 model.output2$rsquared.adjusted #> [1] -0.09225093 # -0.0834906813  ######## EXAMPLE 3 (after EXAMPLE 2). ADDING A MICRO-MICRO INTERACTION TERM ######## model.formula3 = as.formula(y ~ BLUP.x.var1 * BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2) model.output3 = micromacro.lm(model.formula3, results$adjusted.group.means, y,                               results$unequal.groups) micromacro.summary(model.output3) #> Call: #> micromacro.lm( y ~ BLUP.x.var1 * BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2, ...) #>      #> Residuals: #>        Min        1Q   Median       3Q      Max #>  -14.03965 -3.061697 1.708925 3.492015 8.497856 #>  #>      #> Coefficients: #>                              Estimate         S.E. df            t  Pr(>|t|) #> (Intercept)             -3.705789e+02 1610.5294900 33 -0.230097569 0.8194364 #> BLUP.x.var1              7.644314e+00   31.8869271 33  0.239731909 0.8120210 #> BLUP.x.var2              2.166514e+01   80.8635210 33  0.267922269 0.7904268 #> BLUP.x.var3              8.236089e-01    1.9448619 33  0.423479363 0.6746930 #> z.var1                   1.221233e+00    1.0761068 33  1.134862263 0.2646092 #> z.var2                   4.283912e-03    0.6149142 33  0.006966682 0.9944834 #> BLUP.x.var1:BLUP.x.var2 -4.306982e-01    1.6078172 33 -0.267877614 0.7904608 #>                                   r #> (Intercept)             0.040022752 #> BLUP.x.var1             0.041695677 #> BLUP.x.var2             0.046588638 #> BLUP.x.var3             0.073518801 #> z.var1                  0.193808416 #> z.var2                  0.001212743 #> BLUP.x.var1:BLUP.x.var2 0.046580890 #>  #> --- #> Residual standard error: 5.16191 on 33 degrees of freedom #> Multiple R-squared: 0.049847345, Adjusted R-squared: -0.1229076832 #> F-statistic: 0.28854 on 6 and 33 DF, p-value: 0.93819 # Call: #   micromacro.lm( y ~ BLUP.x.var1 * BLUP.x.var2 + BLUP.x.var3 + z.var1 + z.var2, ...) # # Residuals: #        Min        1Q    Median       3Q      Max # -13.21948 -2.048324 0.7062639 3.843816 7.924922 # # # Coefficients: #                              Estimate         S.E. df          t  Pr(>|t|)          r # (Intercept)             -1.098875e+03 1962.9182021 33 -0.5598169 0.5793848 0.09699214 # BLUP.x.var1              2.231877e+01   38.9620284 33  0.5728339 0.5706400 0.09922547 # BLUP.x.var2              5.988568e+01   96.0256433 33  0.6236426 0.5371496 0.10792809 # BLUP.x.var3             -9.557605e-01    1.9374178 33 -0.4933167 0.6250560 0.08556050 # z.var1                   6.116347e-01    1.1727757 33  0.5215274 0.6054822 0.09041443 # z.var2                  -8.556163e-02    0.5331509 33 -0.1604829 0.8734790 0.02792560 # BLUP.x.var1:BLUP.x.var2 -1.209354e+00    1.9186909 33 -0.6303016 0.5328380 0.10906688 # # --- #   Residual standard error: 5.08795 on 33 degrees of freedom # Multiple R-squared: 0.0666547309, Adjusted R-squared: -0.103044409 # F-statistic: 0.39278 on 6 and 33 DF, p-value: 0.87831  model.output3$statistics #>                              Estimate         S.E. df            t  Pr(>|t|) #> (Intercept)             -3.705789e+02 1610.5294900 33 -0.230097569 0.8194364 #> BLUP.x.var1              7.644314e+00   31.8869271 33  0.239731909 0.8120210 #> BLUP.x.var2              2.166514e+01   80.8635210 33  0.267922269 0.7904268 #> BLUP.x.var3              8.236089e-01    1.9448619 33  0.423479363 0.6746930 #> z.var1                   1.221233e+00    1.0761068 33  1.134862263 0.2646092 #> z.var2                   4.283912e-03    0.6149142 33  0.006966682 0.9944834 #> BLUP.x.var1:BLUP.x.var2 -4.306982e-01    1.6078172 33 -0.267877614 0.7904608 #>                                   r #> (Intercept)             0.040022752 #> BLUP.x.var1             0.041695677 #> BLUP.x.var2             0.046588638 #> BLUP.x.var3             0.073518801 #> z.var1                  0.193808416 #> z.var2                  0.001212743 #> BLUP.x.var1:BLUP.x.var2 0.046580890 #                              Estimate         S.E. df          t  Pr(>|t|)          r # (Intercept)             -1.098875e+03 1962.9182021 33 -0.5598169 0.5793848 0.09699214 # BLUP.x.var1              2.231877e+01   38.9620284 33  0.5728339 0.5706400 0.09922547 # BLUP.x.var2              5.988568e+01   96.0256433 33  0.6236426 0.5371496 0.10792809 # BLUP.x.var3             -9.557605e-01    1.9374178 33 -0.4933167 0.6250560 0.08556050 # z.var1                   6.116347e-01    1.1727757 33  0.5215274 0.6054822 0.09041443 # z.var2                  -8.556163e-02    0.5331509 33 -0.1604829 0.8734790 0.02792560 # BLUP.x.var1:BLUP.x.var2 -1.209354e+00    1.9186909 33 -0.6303016 0.5328380 0.10906688 model.output3$rsquared #> [1] 0.04984734 # 0.0666547309 model.output3$rsquared.adjusted #> [1] -0.1229077 # -0.103044409  ######## EXAMPLE 4 (after EXAMPLE 2). ADDING A MICRO-MACRO INTERACTION TERM ######## model.formula4 = as.formula(y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 * z.var1 + z.var2) model.output4 = micromacro.lm(model.formula4, results$adjusted.group.means, y,                               results$unequal.groups) micromacro.summary(model.output4) #> Call: #> micromacro.lm( y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 * z.var1 + z.var2, ...) #>      #> Residuals: #>        Min       1Q   Median      3Q      Max #>  -13.84927 -2.95845 1.440022 2.82892 8.830067 #>  #>      #> Coefficients: #>                        Estimate        S.E. df           t  Pr(>|t|)          r #> (Intercept)         73.68055147 163.4923949 33  0.45066654 0.6551771 0.07821067 #> BLUP.x.var1         -0.89383225   2.2118241 33 -0.40411543 0.6887350 0.07017404 #> BLUP.x.var2         -0.04708330   0.7328492 33 -0.06424692 0.9491612 0.01118325 #> BLUP.x.var3          1.19583378   1.8985690 33  0.62986057 0.5331230 0.10899146 #> z.var1             -24.78249408  17.3429303 33 -1.42896810 0.1624116 0.24139507 #> z.var2              -0.09907994   0.5977671 33 -0.16575008 0.8693649 0.02884138 #> BLUP.x.var3:z.var1  -2.60917315   1.7341582 33 -1.50457624 0.1419449 0.25336694 #>  #> --- #> Residual standard error: 4.99891 on 33 degrees of freedom #> Multiple R-squared: 0.1089087413, Adjusted R-squared: -0.0531078512 #> F-statistic: 0.67221 on 6 and 33 DF, p-value: 0.67273 # Call: #   micromacro.lm( y ~ BLUP.x.var1 + BLUP.x.var2 + BLUP.x.var3 * z.var1 + z.var2, ...) # # Residuals: #        Min        1Q    Median       3Q     Max # -12.99937 -1.909645 0.8775397 3.712013 8.46591 # # # Coefficients: #                       Estimate         S.E. df          t  Pr(>|t|)          r # (Intercept)        129.22731579 146.4817031 33  0.8822079 0.3840456 0.15179313 # BLUP.x.var1         -2.10556192   2.3951160 33 -0.8791064 0.3857003 0.15127172 # BLUP.x.var2         -0.63762927   0.8747645 33 -0.7289153 0.4711953 0.12587857 # BLUP.x.var3         -0.53590189   1.8273917 33 -0.2932605 0.7711594 0.05098372 # z.var1               2.95426548  19.1170600 33  0.1545356 0.8781288 0.02689146 # z.var2              -0.09852267   0.5467583 33 -0.1801942 0.8581021 0.03135236 # BLUP.x.var3:z.var1   0.21489002   1.8788995 33  0.1143702 0.9096374 0.01990534 # # --- #   Residual standard error: 5.11747 on 33 degrees of freedom # Multiple R-squared: 0.0557926451, Adjusted R-squared: -0.1158814195 # F-statistic: 0.32499 on 6 and 33 DF, p-value: 0.91909  model.output4$statistics #>                        Estimate        S.E. df           t  Pr(>|t|)          r #> (Intercept)         73.68055147 163.4923949 33  0.45066654 0.6551771 0.07821067 #> BLUP.x.var1         -0.89383225   2.2118241 33 -0.40411543 0.6887350 0.07017404 #> BLUP.x.var2         -0.04708330   0.7328492 33 -0.06424692 0.9491612 0.01118325 #> BLUP.x.var3          1.19583378   1.8985690 33  0.62986057 0.5331230 0.10899146 #> z.var1             -24.78249408  17.3429303 33 -1.42896810 0.1624116 0.24139507 #> z.var2              -0.09907994   0.5977671 33 -0.16575008 0.8693649 0.02884138 #> BLUP.x.var3:z.var1  -2.60917315   1.7341582 33 -1.50457624 0.1419449 0.25336694 #                       Estimate         S.E. df          t  Pr(>|t|)          r # (Intercept)        129.22731579 146.4817031 33  0.8822079 0.3840456 0.15179313 # BLUP.x.var1         -2.10556192   2.3951160 33 -0.8791064 0.3857003 0.15127172 # BLUP.x.var2         -0.63762927   0.8747645 33 -0.7289153 0.4711953 0.12587857 # BLUP.x.var3         -0.53590189   1.8273917 33 -0.2932605 0.7711594 0.05098372 # z.var1               2.95426548  19.1170600 33  0.1545356 0.8781288 0.02689146 # z.var2              -0.09852267   0.5467583 33 -0.1801942 0.8581021 0.03135236 # BLUP.x.var3:z.var1   0.21489002   1.8788995 33  0.1143702 0.9096374 0.01990534 model.output4$rsquared #> [1] 0.1089087 # 0.0557926451 model.output4$rsquared.adjusted #> [1] -0.05310785 # -0.1158814195"}]
